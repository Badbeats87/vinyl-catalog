// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Core catalog entity - represents a vinyl release
model Release {
  id              String   @id @default(cuid())
  title           String   @db.VarChar(255)
  artist          String   @db.VarChar(255)
  label           String?  @db.VarChar(255)
  catalogNumber   String?  @db.VarChar(100)
  barcode         String?  @db.VarChar(20)
  releaseYear     Int?
  genre           String?  @db.VarChar(100)
  coverArtUrl     String?  @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  marketSnapshots MarketSnapshot[]
  submissionItems SubmissionItem[]
  inventoryLots   InventoryLot[]
  pricingAudits   PricingCalculationAudit[]
  salesHistory    SalesHistory[]

  @@index([barcode])
  @@index([artist, title])
  @@index([genre])
}

// Market data snapshot from Discogs/eBay
model MarketSnapshot {
  id        String   @id @default(cuid())
  releaseId String
  release   Release  @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  source    String   @db.VarChar(50) // "discogs" or "ebay"
  statLow   Float?   // Lowest price seen
  statMedian Float?  // Median/average price
  statHigh  Float?   // Highest price seen
  fetchedAt DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  pricingAudits PricingCalculationAudit[]

  @@unique([releaseId, source])
  @@index([releaseId])
  @@index([source])
  @@index([fetchedAt])
}

// Condition tier reference data (read-only, seeded at init)
model ConditionTier {
  id       String @id @default(cuid())
  name     String @unique @db.VarChar(50) // "Mint", "NM", "VG+", "VG", "VG-", "G"
  order    Int    @unique // 1-6 for sorting
  mediaAdjustment   Float  // e.g., 1.10 for Mint (110% of baseline)
  sleeveAdjustment  Float  // e.g., 1.10 for Mint sleeve
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  policyDiscounts PolicyConditionDiscount[]

  @@index([name])
}

// Admin-configurable pricing rules
model PricingPolicy {
  id             String   @id @default(cuid())
  name           String   @db.VarChar(255)
  description    String?  @db.Text
  scope          String   @db.VarChar(50) // "global", "genre", "release"
  scopeValue     String?  @db.VarChar(255) // genre name or release_id if scope-specific

  // Buy formula parameters
  buyMarketSource String   @db.VarChar(50) @default("discogs") // "discogs", "ebay", "hybrid"
  buyMarketStat   String   @db.VarChar(50) @default("median") // "low", "median", "high"
  buyPercentage   Float    @default(0.55) // 55% of market for offers
  buyMinCap       Float?   // Minimum offer price
  buyMaxCap       Float?   // Maximum offer price
  offerExpiryDays Int      @default(7) // How long offers are valid

  // Sell formula parameters
  sellMarketSource String  @db.VarChar(50) @default("discogs") // "discogs", "ebay", "hybrid"
  sellMarketStat  String   @db.VarChar(50) @default("median") // "low", "median", "high"
  sellPercentage  Float    @default(1.25) // 125% of market for list prices
  sellMinCap      Float?   // Minimum list price
  sellMaxCap      Float?   // Maximum list price

  // Condition curve application
  applyConditionAdjustment Boolean @default(true)
  mediaWeight     Float    @default(0.5) // Media vs. sleeve split (50/50)
  sleeveWeight    Float    @default(0.5)

  // Rounding
  roundingIncrement Float  @default(0.25) // Round to nearest $0.25

  // Admin overrides & special rules
  requiresManualReview Boolean @default(false) // Flag for missing data
  profitMarginTarget Float?  // e.g., 0.40 for 40% margin target

  isActive         Boolean  @default(true)
  version          Int      @default(1) // Track policy versions for audit trail
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  auditLogs        PricingCalculationAudit[]
  conditionDiscounts PolicyConditionDiscount[]

  @@index([scope, scopeValue])
  @@index([isActive])
}

// Policy condition discounts - per-condition pricing adjustments
model PolicyConditionDiscount {
  id                      String   @id @default(cuid())
  policyId                String
  conditionTierId         String
  buyDiscountPercentage   Float    @default(0) // e.g., 15 for 15% discount on buying offers
  sellDiscountPercentage  Float    @default(0) // e.g., 10 for 10% discount on selling prices

  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  // Relations
  policy                  PricingPolicy @relation(fields: [policyId], references: [id], onDelete: Cascade)
  conditionTier           ConditionTier @relation(fields: [conditionTierId], references: [id], onDelete: Restrict)

  @@unique([policyId, conditionTierId])
  @@index([policyId])
  @@index([conditionTierId])
}

// Seller submission (incoming offer request)
model SellerSubmission {
  id              String   @id @default(cuid())
  submissionNumber String   @unique // Human-readable identifier
  sellerEmail     String   @db.VarChar(255)
  sellerPhone     String?  @db.VarChar(20)

  status          String   @db.VarChar(50) @default("pending_review")
  // Status values: pending_review, accepted, rejected, counter_offered, payment_sent, expired

  notes           String?  @db.Text
  photosUrl       String?  @db.Text // JSON array of URLs

  expectedPayout  Float?   // Calculated sum of offers
  actualPayout    Float?   // After admin acceptance

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  expiresAt       DateTime // Offer expiry date

  // Relations
  items           SubmissionItem[]
  history         SubmissionHistory[]

  @@index([status])
  @@index([sellerEmail])
  @@index([createdAt])
  @@index([expiresAt])
}

// Line items in a seller submission
model SubmissionItem {
  id              String   @id @default(cuid())
  submissionId    String
  submission      SellerSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  releaseId       String
  release         Release  @relation(fields: [releaseId], references: [id], onDelete: Restrict)

  quantity        Int      @default(1)
  sellerConditionMedia  String  @db.VarChar(50)   // "Mint", "NM", etc.
  sellerConditionSleeve String  @db.VarChar(50)   // "Mint", "NM", etc.

  autoOfferPrice  Float    // Calculated based on pricing policy
  itemNotes       String?  @db.Text

  status          String   @db.VarChar(50) @default("pending")
  // Status: pending, accepted, rejected, counter_offered, received_and_inspected, finalized

  finalConditionMedia  String?  @db.VarChar(50)  // After inspection
  finalConditionSleeve String?  @db.VarChar(50)
  finalOfferPrice Float?   // After any admin adjustment

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  history         SubmissionHistory[]

  @@index([submissionId])
  @@index([releaseId])
  @@index([status])
}

// Inventory lot ready for sale
model InventoryLot {
  id              String   @id @default(cuid())
  lotNumber       String   @unique // Human-readable identifier
  releaseId       String
  release         Release  @relation(fields: [releaseId], references: [id], onDelete: Restrict)

  conditionMedia  String   @db.VarChar(50)
  conditionSleeve String   @db.VarChar(50)

  costBasis       Float    // What we paid for it
  listPrice       Float    // What we're selling it for
  channel         String   @db.VarChar(50) // "web", "store_walkIn", etc.

  status          String   @db.VarChar(50) @default("draft")
  // Status: draft, live, reserved, sold, returned, damaged

  quantity        Int      @default(1)
  availableQuantity Int   @default(1) // Decremented when reserved

  internalNotes   String?  @db.Text

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  listedAt        DateTime? // When it went live

  // Relations
  cartItems       CartItem[]
  orderItems      OrderItem[]
  salesHistory    SalesHistory[]

  @@index([releaseId])
  @@index([status])
  @@index([channel])
  @@index([listPrice])
}

// Audit log for pricing calculations
model PricingCalculationAudit {
  id              String   @id @default(cuid())
  releaseId       String
  release         Release  @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  policyId        String
  policy          PricingPolicy @relation(fields: [policyId], references: [id], onDelete: Restrict)
  marketSnapshotId String?
  marketSnapshot  MarketSnapshot? @relation(fields: [marketSnapshotId], references: [id], onDelete: SetNull)

  calculationType String   @db.VarChar(50) // "buy_offer", "sell_price"

  // Inputs to calculation
  conditionMedia  String   @db.VarChar(50)
  conditionSleeve String   @db.VarChar(50)
  marketPrice     Float?   // The market price used

  // Output
  calculatedPrice Float

  // Calculation breakdown
  calculationDetails String? @db.Text // JSON breakdown of how price was calculated

  createdAt       DateTime @default(now())

  @@index([releaseId])
  @@index([policyId])
  @@index([createdAt])
}

// Admin decision history for submissions
model SubmissionHistory {
  id              String   @id @default(cuid())
  submissionId    String
  submission      SellerSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  submissionItemId String?
  submissionItem  SubmissionItem? @relation(fields: [submissionItemId], references: [id], onDelete: Cascade)

  actionType      String   @db.VarChar(50) // "accepted", "rejected", "counter_offered", "received_and_inspected", "finalized"
  adminNotes      String?  @db.Text

  // For condition updates
  finalConditionMedia String? @db.VarChar(50)
  finalConditionSleeve String? @db.VarChar(50)

  // For counter-offer or final price adjustments
  adjustedPrice   Float?

  // For tracking seller response to counter-offer
  sellerResponse  String?  @db.VarChar(50) // "pending", "accepted", "rejected"
  sellerResponseAt DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([submissionId])
  @@index([submissionItemId])
  @@index([actionType])
  @@index([createdAt])
}

// Buyer account (storefront customer)
model Buyer {
  id              String   @id @default(cuid())
  email           String   @unique @db.VarChar(255)
  name            String?  @db.VarChar(255)

  // Contact info
  phone           String?  @db.VarChar(20)

  // Shipping address
  shippingAddress String?  @db.Text // JSON object with: street, city, state, zip, country
  billingAddress  String?  @db.Text // JSON object, or null to use shipping

  // Preferences
  notifications   Boolean  @default(true)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  carts           ShoppingCart[]
  orders          BuyerOrder[]

  @@index([email])
}

// Shopping cart for buyer
model ShoppingCart {
  id              String   @id @default(cuid())
  buyerId         String
  buyer           Buyer    @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  // Cart state
  status          String   @db.VarChar(50) @default("active")
  // Status: active, abandoned, checked_out

  subtotal        Float    @default(0)
  tax             Float    @default(0)
  shipping        Float    @default(0)
  total           Float    @default(0)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  abandonedAt     DateTime? // When cart was abandoned (if applicable)

  // Relations
  items           CartItem[]

  @@index([buyerId])
  @@index([status])
  @@index([createdAt])
}

// Cart line item
model CartItem {
  id              String   @id @default(cuid())
  cartId          String
  cart            ShoppingCart @relation(fields: [cartId], references: [id], onDelete: Cascade)

  lotId           String
  lot             InventoryLot @relation(fields: [lotId], references: [id], onDelete: Restrict)

  // Item-level pricing (captured at time of add)
  pricePerUnit    Float
  quantity        Int      @default(1)
  lineTotal       Float

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([cartId])
  @@index([lotId])
  @@unique([cartId, lotId]) // One entry per lot per cart
}

// Buyer order
model BuyerOrder {
  id              String   @id @default(cuid())
  orderNumber     String   @unique // Human-readable identifier
  buyerId         String
  buyer           Buyer    @relation(fields: [buyerId], references: [id], onDelete: Restrict)

  // Order state
  status          String   @db.VarChar(50) @default("pending_payment")
  // Status: pending_payment, payment_processing, paid, shipment_pending, shipped, delivered, cancelled, returned

  // Pricing
  subtotal        Float
  tax             Float
  shipping        Float
  total           Float

  // Payment info
  paymentMethod   String   @db.VarChar(50) // "paypal", "card", etc.
  paypalOrderId   String?  @db.VarChar(255) // PayPal order ID for tracking
  paymentStatus   String?  @db.VarChar(50) // "pending", "authorized", "captured", "failed", "refunded"

  // Shipping
  shippingAddress String   @db.Text // JSON: street, city, state, zip, country, name, phone
  trackingNumber  String?  @db.VarChar(255)

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  paidAt          DateTime?
  shippedAt       DateTime?
  deliveredAt     DateTime?

  // Relations
  items           OrderItem[]
  payments        Payment[]
  refunds         Refund[]

  @@index([buyerId])
  @@index([status])
  @@index([paymentStatus])
  @@index([createdAt])
}

// Order line item
model OrderItem {
  id              String   @id @default(cuid())
  orderId         String
  order           BuyerOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  lotId           String
  lot             InventoryLot @relation(fields: [lotId], references: [id], onDelete: Restrict)

  // Item pricing (captured at time of order)
  pricePerUnit    Float
  quantity        Int      @default(1)
  lineTotal       Float

  createdAt       DateTime @default(now())

  @@index([orderId])
  @@index([lotId])
}

// Channel configuration for visibility rules
model ChannelConfig {
  id              String   @id @default(cuid())
  channel         String   @unique @db.VarChar(50) // "web", "store_walkIn", etc.
  displayName     String   @db.VarChar(255)
  isPublic        Boolean  @default(false) // Whether this channel is visible to buyers
  isSellable      Boolean  @default(true)  // Can items on this channel be purchased?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([isPublic])
}

// Sales history for analytics and pricing strategies
model SalesHistory {
  id              String   @id @default(cuid())
  lotId           String
  lot             InventoryLot @relation(fields: [lotId], references: [id], onDelete: Cascade)

  releaseId       String
  release         Release  @relation(fields: [releaseId], references: [id], onDelete: Cascade)

  // What we paid for it
  costBasis       Float

  // What we sold it for
  salePricePerUnit Float
  quantity        Int      @default(1)
  totalSalePrice  Float    // quantity * salePricePerUnit

  // Profit metrics
  grossProfit     Float    // totalSalePrice - (costBasis * quantity)
  profitMargin    Float    // grossProfit / totalSalePrice (as decimal, e.g., 0.35 for 35%)

  // Condition info at time of sale
  conditionMedia  String   @db.VarChar(50)
  conditionSleeve String   @db.VarChar(50)

  // Market context at time of sale
  discogsPrice    Float?   // Discogs median price at time of sale
  ebayPrice       Float?   // eBay median price at time of sale

  // Sale channel
  channel         String   @db.VarChar(50) // "web", "store_walkIn", etc.

  soldAt          DateTime @default(now()) // When the sale was recorded

  @@index([releaseId])
  @@index([lotId])
  @@index([soldAt])
  @@index([channel])
  @@index([profitMargin])
}

// Stripe payment record
model Payment {
  id                      String   @id @default(cuid())
  orderId                 String
  order                   BuyerOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Stripe integration
  stripePaymentIntentId   String   @unique
  stripeCustomerId        String

  // Payment details
  amount                  Int      // Amount in cents
  currency                String   @db.VarChar(3) // "USD", "EUR", etc.
  status                  String   @db.VarChar(50) // "pending", "completed", "failed"

  // Timestamps
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  // Relations
  refunds                 Refund[]

  @@index([orderId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@index([createdAt])
}

// Refund record
model Refund {
  id          String   @id @default(cuid())
  paymentId   String
  payment     Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  orderId     String
  order       BuyerOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Refund details
  amount      Int      // Amount in cents
  reason      String   @db.VarChar(255)
  status      String   @db.VarChar(50) // "pending", "completed", "failed"

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([paymentId])
  @@index([orderId])
  @@index([status])
  @@index([createdAt])
}

